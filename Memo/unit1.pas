unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls, unit2;

type

  { TForm1 }

  TForm1 = class(TForm)
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Button4: TButton;
    Memo1: TMemo;
    Memo2: TMemo;
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
  private

  public

  end;

var
  Form1: TForm1;

  // Делаем матрицу и её размерность глобальными переменными
  // чтобы они были видны во всех функциях -
  // обработчиков нажатия кнопок
  a: Ar;
  n : integer;

implementation

{$R *.lfm}

{ TForm1 }


// удобно будет создать процедуру вывода матрицы в объект типа TMemo
// 'var output:TMemo' так как мы будем изменять объект Memo - записывать в него
// Хотя это не обязательно, работает и без, тупо для приличия делаем так
procedure printAr(a: Ar; n: integer; var output: TMemo);
var
  // строковое представление одного числа
  s_x: string;
  // вспомогательная строка, чтобы добавить элементы матрицы
  // то есть это сумма строковых представлений каждого элемента(s_x) матрциы
  s: string;
  // переменные для циклов обхода матрицы
  i,j: integer;
begin
  // перед записью чего-то в Memo очищаем его
  // В Memo могла остаться старая матрица
  output.Clear;

  // сначала мы будем собирать строку из элементов матрицы,
  // лежащих на i-ой строчке
  // Потом добавляем эту строку в Memo через Append
  for i:=1 to n do
  begin
    // присваиваем пустую строку про обработке каждой строки матрицы
    // То есть обработали одну строку, очистили переменную, обработать другую
    // иначе элементы с другой (предыдущей) строки будут выводиться и в новой строке
    s := '';
    for j:=1 to n do
    begin
      // преобразуем елемент матрицы в строку
      // число 5 - так же как и в writeln - ширина поля под число
      // чтобы не замарачиваться с пробелами при выводе
      str(a[i,j]:5, s_x);
      // по одному элементы i-ой строки собираем в одну строку
      s := s + s_x;
    end;
    // собрали одну строку, теперь добавляем её в Memo
    output.Append(s);

  end;
end;


{Считываем матрицу из Memo}
// 'var' чтобы изменить переменные передавааемые в функцию
// input: TMemo без var т.к. мы только считываем оттуда
procedure ReadAr(var a: Ar; var n: integer; input:TMemo);
var i, j: integer;
    c: integer; // номер столбца элемента - счётчик
    s_x: string; // строковое представление елемента матрицы

begin

  // Чтобы каждый раз не писать через точку, обращаясь к атрибутам input
  // Раньше бы пришлось писать input.Lines, теперь же просто достаточно
  // Написать только Lines
  with input do
  begin
    // Перебираем строки из Memo, причом внутри with
    // не надо писать input.Lines.Count
    for i:=0 to Lines.Count-1 do
    begin
      j :=1;  // Счётчик СИМВОЛОВ в строке
      c := 0; // Счётчик ЭЛЕМЕНТОВ - найденных ЧИСЕЛ
      // Перебираем i-ую строку посимвольно
      while (j <= length(Lines[i])) do
      begin
        // собираем из символов число
        s_x := ''; // cтрока цифр - элемент матрицы в виде строки
        while ((j <= length(Lines[i])) and (Lines[i][j] in ['0' .. '9'])) do
        begin
           s_x := s_x + Lines[i][j];
           j:= j + 1;
        end;

        // Нужно сделать проверку
        // Вдруг вначале стояли пробелы и мы даже не начали цикл выше
        // то есть Lines[i][j] in ['0' .. '9'] - ЛОЖЬ

        // если строковое представление элемента - НЕ пустая строка
        if (not (s_x = '')) then
        begin
          // Мы смогли собрать число
          // Увеличиваем счётчик элементов в одной строке
          c:= c + 1;
          // И добавляем число в матрицу
          // i+1 - тк строки в Memo нумеруются с 0, а в матрице с 1
          a[i+1, c] := StrToInt(s_x); // нужно привести к целому типу

          // По поводу счётчика елементов 'с' - счётчика чисел в строке
          // мы не можем перебрать элементы из строки в цикле for
          // так как не известно их количество
          // так же мы не можем перебрать элемнты считывая их по одному
          // как в readln т.к. мы имеем только строки и мы должны преобразовать
          // последовательность символов в ЦЕЛОЧИСЛЕННЫЕ элементы матрицы
          // Счётчик элементов 'c' в строке будет увеличиваться каждый раз,
          // когда мы находим(собираем из символом) число в строке
          // и  он будет обнуляться при переходе на новую строку
        end;

        // если мы здесь то дальше какой-то символ - НЕ цифра

        // Перебираем строку до тех пор пока не попадём не цыфру
        // Нам нужны только цыфры, а остальные символы просто пропускаем
        while ((j <= length(Lines[i])) and not (Lines[i][j] in ['0' .. '9'])) do
          j := j + 1;
      end;
    end;
  end;
  // Нужно также задать РАЗМЕРНОСТЬ полученной матрицы
  // Причом здесь уже обязательно писать AMemo.Lines.Count,
  // так как мы не внутри инструкции with
  n:= input.Lines.Count; // число строк и столбцов = числу строк в Memo
end;

{Нажали 'Ввести матрицу'}
procedure TForm1.Button1Click(Sender: TObject);
begin
    // Получаем размерность матрицы от пользователя
    // InputBox возвращает строку, но ГЛОБАЛЬНАЯ переменная 'n' типа integer
    // поэтому преобразуем возвращаем значение в целое число при помощи StrToInt
    n := StrToInt(InputBox('Размерность матрицы', 'Введите целое число', '5'));

    // Теперь так как УЖЕ ЕСТЬ число строк и столбцов
    // Заполняем матрицу
    NewAr(a, n);

    // выводим матрицу в Memo1 - исходная матрица
    PrintAr(a, n, Memo1);

end;

{Нажали 'ПО ЧС'}
procedure TForm1.Button2Click(Sender: TObject);
var k: integer;
begin
  // получаем сколько поворотов нужно сделать
  k := StrToInt(InputBox('Количество Поворотов', 'Введите целое число', '1'));

  // Считываем матрицу из Memo1
  ReadAr(a, n, Memo1);

  // true - истина - крутим ПО ЧС
  KTurnAr(a, n, k, true);

  // выводим изменённую матрицу в Memo2
  printAr(a,n, Memo2);

end;

{Нажали 'ПРОТИВ ЧС'}
procedure TForm1.Button3Click(Sender: TObject);
var k: integer;
begin
  // получаем сколько поворотов нужно сделать
  k := StrToInt(InputBox('Количество Поворотов', 'Введите целое число', '1'));

  // Считываем матрицу из Memo1
  ReadAr(a, n, Memo1);

  // false - истина - крутим ПРОТИВ ЧС
  KTurnAr(a, n, k, false);

  // выводим изменённую матрицу в Memo2
  printAr(a,n, Memo2);
end;

procedure TForm1.Button4Click(Sender: TObject);
begin
  close;
end;

end.

