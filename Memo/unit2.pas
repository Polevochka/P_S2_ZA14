unit Unit2;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils;

// Создадит тип двухмерного массива,
//чтобы можно было передавать матрицы в различные функции

// Причом важно описать этот тип именно в области interface,
// а то данный тип не будет виден в модуле unit1,
// куда подключается наш модуль unit2 с этим типом
type
  Ar = array [1..10, 1..10] of integer;


// Прототипы функций - просто их заголовки
// - это те функции которые должны быть видны в модуле unit1 - та же причина,
// что и с типом unit1

// Интересно будет заметить,
// что процедуры OneTurnProtivChasovoy и OneTurnPoChasovoy
// нигде не используются кроме как в KTurnAr- ТОЛЬКО внутри, НО НЕ за ПРЕДЕЛАМИ
// следовательно они не должны быть видны за пределами unit2 в unit1

procedure NewAr(var a: Ar; n: integer);
procedure KTurnAr(var a: Ar; n: integer; k:  integer; around: boolean);

implementation

{Процедура заполнения матрицы рандомными числами}
//'var a' - т.к. меняем элементы матрицы
//  'n' - разменрность матрицы - число строк и столбцов
procedure NewAr(var a: Ar; n : integer);
var i, j: integer;
begin
   randomize;  // Для генератора случайных чисел - более случайное число
   for i:=1 to n do
       for j:=1 to n do
           a[i,j] := random(100); // рандомное число на отрезке [0;99]
end;

{Процедура делает ОДИН поворот элементов матрицы ПО ЧС}
//'var a' - т.к. меняем элементы матрицы
{
нам нужно повернуть элементы расположенные в этом треугольнике

1 1 1 1
0 1 0 1
0 0 1 1
0 0 0 1
}
procedure OneTurnPoChasovoy(var a: Ar; n:integer);
var i,j: integer;
  temp: integer; // вспомогательная переменная, для перемещения элементов
begin

   // как мы будем делать
   // сначала сохраним какой-нибудь элемент матрицы, лежащий в этом треугольнике
   // в буферную переменную temp
   // потом все элементы сдвинем на одну позицию по часовой, затиря его
   // и вконце ставим его на освободившееся место

   temp := a[1,1]; // удобно выбрать этот элемент

   // обходим главную диагональ
   // элемент на главной диагонали - когда номер строка = номеру столбца
   // то есть имеет индекс a[i,i]
   for i:= 1 to n-1 do
   begin
     a[i,i] := a[i+1, i+1]; // сдвигаем элементы ПО ЧС
   end;
   {
    то есть было:
    1 9 8 7
    0 2 0 6
    0 0 3 5
    0 0 0 4

    столо:
    2 9 8 7
    0 3 0 6
    0 0 4 5
    0 0 0 4   - не забывам что 1 мы сохранили в temp
    }

   // обходим последний столбец j = n
   for i:= n downto 2 do
   begin
     a[i,n] := a[i-1,n];
   end;

   {
    то есть было:
    2 9 8 7
    0 3 0 6
    0 0 4 5
    0 0 0 4

    столо:
    2 9 8 7
    0 3 0 7
    0 0 4 6
    0 0 0 5
    }

    // обходим первую строку i = 1;
    for j:= n downto 2 do
    begin
      a[1,j] := a[1,j-1];
    end;
    {
    то есть было:
    2 9 8 7
    0 3 0 7
    0 0 4 6
    0 0 0 5

    столо:
    2 2 9 8
    0 3 0 7
    0 0 4 6
    0 0 0 5
    }

    // видно, что теперь два первых элемента в первой строке дублируются
    // теперь как раз можно вставить наш сохранённый элемент
    a[1,2] := temp;
    {
    стало:
    2 1 9 8
    0 3 0 7
    0 0 4 6
    0 0 0 5   - задача выполнена
    }

end;

{Процедура делает ОДИН поворот элементов матрицы ПРОТИВ ЧС}
//'var a' - т.к. меняем элементы матрицы
{
нам нужно повернуть элементы расположенные в этом треугольнике

1 1 1 1
0 1 0 1
0 0 1 1
0 0 0 1
}
procedure OneTurnProtivChasovoy(var a: Ar; n:integer);
var i,j: integer;
  temp: integer; // вспомогательная переменная, для перемещения элементов
begin

   // как мы будем делать
   // сначала сохраним какой-нибудь элемент матрицы, лежащий в этом треугольнике
   // в буферную переменную temp
   // потом все элементы сдвинем на одну позицию против часовой, затиря его
   // и вконце ставим его на освободившееся место

   temp := a[n,n]; // удобно выбрать этот элемент

   // обходим главную диагональ
   // элемент на главной диагонали - когда номер строка = номеру столбца
   // то есть имеет индекс a[i,i]
   for i:= n downto 2 do
   begin
     a[i,i] := a[i-1, i-1]; // сдвигаем элементы ПО ЧС
   end;
   {
    то есть было:
    7 6 5 4
    0 8 0 3
    0 0 9 2
    0 0 0 1

    столо:
    7 6 5 4
    0 7 0 3
    0 0 8 2
    0 0 0 9   - не забывам что 1 мы сохранили в temp
    }

   // обходим первую строку i = 1;
    for j:= 1 to n-1 do
    begin
      a[1,j] := a[1,j+1];
    end;
    {
    то есть было:
    7 6 5 4
    0 7 0 3
    0 0 8 2
    0 0 0 9

    столо:
    6 5 4 4
    0 7 0 3
    0 0 8 2
    0 0 0 9
    }

   // обходим последний столбец j = n
   for i:= 1 to n-1 do
   begin
     a[i,n] := a[i+1,n];
   end;

   {
    то есть было:
    6 5 4 4
    0 7 0 3
    0 0 8 2
    0 0 0 9

    столо:
    6 5 4 3
    0 7 0 2
    0 0 8 9
    0 0 0 9
    }


    // видно, что теперь два последних элемента в последнем столбце дублируются
    // теперь как раз можно вставить наш сохранённый элемент
    a[n-1,n] := temp;
    {
    стало:
    6 5 4 3
    0 7 0 2
    0 0 8 1
    0 0 0 9   - задача выполнена
    }

end;

{Процедура поворачивает элементы матрицы k раз}
//'var a' - т.к. меняем элементы матрицы
// k - число поворотов
// around - логическая переменная
//         если истина(true) - то поворот ПО ЧАСОВОЙ стрелке
//         если ложь(false) - то ПРОТИВ ЧАСОВОЙ стрелки
procedure KTurnAr(var a: Ar; n: integer; k:  integer; around: boolean);
var i: integer;
begin
   for i:=1 to k do
   begin
     if (around) then  OneTurnPoChasovoy(a, n)
     else OneTurnProtivChasovoy(a, n);
   end;
end;

end.
